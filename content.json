{"meta":{"title":"fdw'blog","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"gallery","date":"2022-01-08T10:01:26.000Z","updated":"2022-01-08T10:01:26.682Z","comments":true,"path":"gallery/index.html","permalink":"http://example.com/gallery/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"病了","date":"2023-09-18T02:49:50.401Z","updated":"2022-01-06T09:19:26.537Z","comments":true,"path":"2023/09/18/病了/","link":"","permalink":"http://example.com/2023/09/18/%E7%97%85%E4%BA%86/","excerpt":"","text":"感觉自己睡的也不是很晚一眼醒过来就是12点随便吃个午饭看个手机头又开始晕乎乎又上床躺着再醒过来都四点了什么都不想干就脑子放空感觉我病了 有没有药可以救我","categories":[],"tags":[]},{"title":"MySQL","slug":"MySQL","date":"2023-09-18T02:49:50.372Z","updated":"2022-05-04T02:27:13.756Z","comments":true,"path":"2023/09/18/MySQL/","link":"","permalink":"http://example.com/2023/09/18/MySQL/","excerpt":"","text":"基础篇通用语法及分类 DDL: 数据定义语言，用来定义数据库对象（数据库、表、字段） DML: 数据操作语言，用来对数据库表中的数据进行增删改 DQL: 数据查询语言，用来查询数据库中表的记录 DCL: 数据控制语言，用来创建数据库用户、控制数据库的控制权限 DDL（数据定义语言）数据定义语言 数据库操作查询所有数据库：SHOW DATABASES;查询当前数据库：SELECT DATABASE();创建数据库：CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];删除数据库：DROP DATABASE [ IF EXISTS ] 数据库名;使用数据库：USE 数据库名; 注意事项 UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集 表操作查询当前数据库所有表：SHOW TABLES;查询表结构：DESC 表名;查询指定表的建表语句：SHOW CREATE TABLE 表名; 创建表： 1234567CREATE TABLE 表名( 字段1 字段1类型 [COMMENT 字段1注释], 字段2 字段2类型 [COMMENT 字段2注释], 字段3 字段3类型 [COMMENT 字段3注释], ... 字段n 字段n类型 [COMMENT 字段n注释])[ COMMENT 表注释 ]; 最后一个字段后面没有逗号 添加字段：ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];例：ALTER TABLE emp ADD nickname varchar(20) COMMENT '昵称'; 修改数据类型：ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);修改字段名和字段类型：ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];例：将emp表的nickname字段修改为username，类型为varchar(30)ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT '昵称'; 删除字段：ALTER TABLE 表名 DROP 字段名; 修改表名：ALTER TABLE 表名 RENAME TO 新表名 删除表：DROP TABLE [IF EXISTS] 表名;删除表，并重新创建该表：TRUNCATE TABLE 表名; DML（数据操作语言）添加数据指定字段：INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);全部字段：INSERT INTO 表名 VALUES (值1, 值2, ...); 批量添加数据：INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...); 注意事项 字符串和日期类型数据应该包含在引号中 插入的数据大小应该在字段的规定范围内 更新和删除数据修改数据：UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];例：UPDATE emp SET name = 'Jack' WHERE id = 1; 删除数据：DELETE FROM 表名 [ WHERE 条件 ]; DQL（数据查询语言）语法： 1234567891011121314SELECT 字段列表FROM 表名字段WHERE 条件列表GROUP BY 分组字段列表HAVING 分组后的条件列表ORDER BY 排序字段列表LIMIT 分页参数 基础查询查询多个字段：SELECT 字段1, 字段2, 字段3, ... FROM 表名;SELECT * FROM 表名; 设置别名：SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名;SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名; 去除重复记录：SELECT DISTINCT 字段列表 FROM 表名; 转义：SELECT * FROM 表名 WHERE name LIKE '/_张三' ESCAPE '/'/ 之后的_不作为通配符 条件查询语法：SELECT 字段列表 FROM 表名 WHERE 条件列表; 条件： 比较运算符 功能 &gt; 大于 &gt;= 大于等于 &lt; 小于 &lt;= 小于等于 = 等于 &lt;&gt; 或 != 不等于 BETWEEN … AND … 在某个范围内（含最小、最大值） IN(…) 在in之后的列表中的值，多选一 LIKE 占位符 模糊匹配（_匹配单个字符，%匹配任意个字符） IS NULL 是NULL 逻辑运算符 功能 AND 或 &amp;&amp; 并且（多个条件同时成立） OR 或 || 或者（多个条件任意一个成立） NOT 或 ! 非，不是 例子： 123456789101112131415161718192021222324252627-- 年龄等于30select * from employee where age = 30;-- 年龄小于30select * from employee where age &lt; 30;-- 小于等于select * from employee where age &lt;= 30;-- 没有身份证select * from employee where idcard is null or idcard = '';-- 有身份证select * from employee where idcard;select * from employee where idcard is not null;-- 不等于select * from employee where age != 30;-- 年龄在20到30之间select * from employee where age between 20 and 30;select * from employee where age &gt;= 20 and age &lt;= 30;-- 下面语句不报错，但查不到任何信息select * from employee where age between 30 and 20;-- 性别为女且年龄小于30select * from employee where age &lt; 30 and gender = '女';-- 年龄等于25或30或35select * from employee where age = 25 or age = 30 or age = 35;select * from employee where age in (25, 30, 35);-- 姓名为两个字select * from employee where name like '__';-- 身份证最后为Xselect * from employee where idcard like '%X'; 聚合查询（聚合函数）常见聚合函数： 函数 功能 count 统计数量 max 最大值 min 最小值 avg 平均值 sum 求和 语法：SELECT 聚合函数(字段列表) FROM 表名;例：SELECT count(id) from employee where workaddress = \"广东省\"; 分组查询语法：SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ]; where 和 having 的区别： 执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。 判断条件不同：where不能对聚合函数进行判断，而having可以。 例子： 12345678910-- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女）select count(*) from employee group by gender;-- 根据性别分组，统计男性和女性数量select gender, count(*) from employee group by gender;-- 根据性别分组，统计男性和女性的平均年龄select gender, avg(age) from employee group by gender;-- 年龄小于45，并根据工作地址分组select workaddress, count(*) from employee where age &lt; 45 group by workaddress;-- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址select workaddress, count(*) address_count from employee where age &lt; 45 group by workaddress having address_count &gt;= 3; 注意事项 执行顺序：where &gt; 聚合函数 &gt; having 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义 排序查询语法：SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2; 排序方式： ASC: 升序（默认） DESC: 降序 例子： 12345-- 根据年龄升序排序SELECT * FROM employee ORDER BY age ASC;SELECT * FROM employee ORDER BY age;-- 两字段排序，根据年龄升序排序，入职时间降序排序SELECT * FROM employee ORDER BY age ASC, entrydate DESC; 注意事项如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 分页查询语法：SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数; 例子： 1234-- 查询第一页数据，展示10条SELECT * FROM employee LIMIT 0, 10;-- 查询第二页SELECT * FROM employee LIMIT 10, 10; 注意事项 起始索引从0开始，起始索引 = （查询页码 - 1） * 每页显示记录数 分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT 如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10 DQL执行顺序FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT DCL管理用户查询用户： 12USER mysql;SELECT * FROM user; 创建用户:CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码'; 修改用户密码：ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码'; 删除用户：DROP USER '用户名'@'主机名'; 例子： 123456789-- 创建用户test，只能在当前主机localhost访问create user 'test'@'localhost' identified by '123456';-- 创建用户test，能在任意主机访问create user 'test'@'%' identified by '123456';create user 'test' identified by '123456';-- 修改密码alter user 'test'@'localhost' identified with mysql_native_password by '1234';-- 删除用户drop user 'test'@'localhost'; 注意事项 主机名可以使用 % 通配 权限控制常用权限： 权限 说明 ALL, ALL PRIVILEGES 所有权限 SELECT 查询数据 INSERT 插入数据 UPDATE 修改数据 DELETE 删除数据 ALTER 修改表 DROP 删除数据库/表/视图 CREATE 创建数据库/表 更多权限请看权限一览表 查询权限：SHOW GRANTS FOR '用户名'@'主机名'; 授予权限：GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名'; 撤销权限：REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名'; 注意事项 多个权限用逗号分隔 授权时，数据库名和表名可以用 * 进行通配，代表所有 函数 字符串函数 数值函数 日期函数 流程函数 字符串函数常用函数： 函数 功能 CONCAT(s1, s2, …, sn) 字符串拼接，将s1, s2, …, sn拼接成一个字符串 LOWER(str) 将字符串全部转为小写 UPPER(str) 将字符串全部转为大写 LPAD(str, n, pad) 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 RPAD(str, n, pad) 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度 TRIM(str) 去掉字符串头部和尾部的空格 SUBSTRING(str, start, len) 返回从字符串str从start位置起的len个长度的字符串 使用示例： 1234567891011121314-- 拼接SELECT CONCAT('Hello', 'World');-- 小写SELECT LOWER('Hello');-- 大写SELECT UPPER('Hello');-- 左填充SELECT LPAD('01', 5, '-');-- 右填充SELECT RPAD('01', 5, '-');-- 去除空格SELECT TRIM(' Hello World ');-- 切片（起始索引为1）SELECT SUBSTRING('Hello World', 1, 5); 数值函数常见函数： 函数 功能 CEIL(x) 向上取整 FLOOR(x) 向下取整 MOD(x, y) 返回x/y的模 RAND() 返回0~1内的随机数 ROUND(x, y) 求参数x的四舍五入值，保留y位小数 日期函数常用函数： 函数 功能 CURDATE() 返回当前日期 CURTIME() 返回当前时间 NOW() 返回当前日期和时间 YEAR(date) 获取指定date的年份 MONTH(date) 获取指定date的月份 DAY(date) 获取指定date的日期 DATE_ADD(date, INTERVAL expr type) 返回一个日期/时间值加上一个时间间隔expr后的时间值 DATEDIFF(date1, date2) 返回起始时间date1和结束时间date2之间的天数 例子： 12-- DATE_ADDSELECT DATE_ADD(NOW(), INTERVAL 70 YEAR); 流程函数常用函数： 函数 功能 IF(value, t, f) 如果value为true，则返回t，否则返回f IFNULL(value1, value2) 如果value1不为空，返回value1，否则返回value2 CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END 如果val1为true，返回res1，… 否则返回default默认值 CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END 如果expr的值等于val1，返回res1，… 否则返回default默认值 例子： 12345678select name, (case when age &gt; 30 then '中年' else '青年' end)from employee;select name, (case workaddress when '北京市' then '一线城市' when '上海市' then '一线城市' else '二线城市' end) as '工作地址'from employee; 约束分类： 约束 描述 关键字 非空约束 限制该字段的数据不能为null NOT NULL 唯一约束 保证该字段的所有数据都是唯一、不重复的 UNIQUE 主键约束 主键是一行数据的唯一标识，要求非空且唯一 PRIMARY KEY 默认约束 保存数据时，如果未指定该字段的值，则采用默认值 DEFAULT 检查约束（8.0.1版本后） 保证字段值满足某一个条件 CHECK 外键约束 用来让两张图的数据之间建立连接，保证数据的一致性和完整性 FOREIGN KEY 约束是作用于表中字段上的，可以再创建表/修改表的时候添加约束。 常用约束 约束条件 关键字 主键 PRIMARY KEY 自动增长 AUTO_INCREMENT 不为空 NOT NULL 唯一 UNIQUE 逻辑条件 CHECK 默认值 DEFAULT 例子： 1234567create table user( id int primary key auto_increment, name varchar(10) not null unique, age int check(age &gt; 0 and age &lt; 120), status char(1) default '1', gender char(1)); 外键约束添加外键： 123456789CREATE TABLE 表名( 字段名 字段类型, ... [CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名));ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);-- 例子alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id); 删除外键：ALTER TABLE 表名 DROP FOREIGN KEY 外键名; 删除/更新行为 行为 说明 NO ACTION 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与RESTRICT一致） RESTRICT 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与NO ACTION一致） CASCADE 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键在子表中的记录 SET NULL 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null） SET DEFAULT 父表有变更时，子表将外键设为一个默认值（Innodb不支持） 更改删除/更新行为：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为; 多表查询多表关系 一对多（多对一） 多对多 一对一 一对多案例：部门与员工关系：一个部门对应多个员工，一个员工对应一个部门实现：在多的一方建立外键，指向一的一方的主键 多对多案例：学生与课程关系：一个学生可以选多门课程，一门课程也可以供多个学生选修实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键 一对一案例：用户与用户详情关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE） 查询合并查询（笛卡尔积，会展示所有组合结果）：select * from employee, dept; 笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积） 消除无效笛卡尔积：select * from employee, dept where employee.dept = dept.id; 内连接查询内连接查询的是两张表交集的部分 隐式内连接：SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...; 显式内连接：SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...; 显式性能比隐式高 例子： 12345-- 查询员工姓名，及关联的部门的名称-- 隐式select e.name, d.name from employee as e, dept as d where e.dept = d.id;-- 显式select e.name, d.name from employee as e inner join dept as d on e.dept = d.id; 外连接查询左外连接：查询左表所有数据，以及两张表交集部分数据SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;相当于查询表1的所有数据，包含表1和表2交集部分数据 右外连接：查询右表所有数据，以及两张表交集部分数据SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...; 例子： 12345-- 左select e.*, d.name from employee as e left outer join dept as d on e.dept = d.id;select d.name, e.* from dept d left outer join emp e on e.dept = d.id; -- 这条语句与下面的语句效果一样-- 右select d.name, e.* from employee as e right outer join dept as d on e.dept = d.id; 左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept 自连接查询当前表与自身的连接查询，自连接必须使用表别名 语法：SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...; 自连接查询，可以是内连接查询，也可以是外连接查询 例子： 1234-- 查询员工及其所属领导的名字select a.name, b.name from employee a, employee b where a.manager = b.id;-- 没有领导的也查询出来select a.name, b.name from employee a left join employee b on a.manager = b.id; 联合查询 union, union all把多次查询的结果合并，形成一个新的查询集 语法： 123SELECT 字段列表 FROM 表A ...UNION [ALL]SELECT 字段列表 FROM 表B ... 注意事项 UNION ALL 会有重复结果，UNION 不会 联合查询比使用or效率高，不会使索引失效 子查询SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个 根据子查询结果可以分为： 标量子查询（子查询结果为单个值） 列子查询（子查询结果为一列） 行子查询（子查询结果为一行） 表子查询（子查询结果为多行多列） 根据子查询位置可分为： WHERE 之后 FROM 之后 SELECT 之后 标量子查询子查询返回的结果是单个值（数字、字符串、日期等）。常用操作符：- &lt; &gt; &gt; &gt;= &lt; &lt;= 例子： 123456789-- 查询销售部所有员工select id from dept where name = '销售部';-- 根据销售部部门ID，查询员工信息select * from employee where dept = 4;-- 合并（子查询）select * from employee where dept = (select id from dept where name = '销售部');-- 查询xxx入职之后的员工信息select * from employee where entrydate &gt; (select entrydate from employee where name = 'xxx'); 列子查询返回的结果是一列（可以是多行）。 常用操作符： 操作符 描述 IN 在指定的集合范围内，多选一 NOT IN 不在指定的集合范围内 ANY 子查询返回列表中，有任意一个满足即可 SOME 与ANY等同，使用SOME的地方都可以使用ANY ALL 子查询返回列表的所有值都必须满足 例子： 123456-- 查询销售部和市场部的所有员工信息select * from employee where dept in (select id from dept where name = '销售部' or name = '市场部');-- 查询比财务部所有人工资都高的员工信息select * from employee where salary &gt; all(select salary from employee where dept = (select id from dept where name = '财务部'));-- 查询比研发部任意一人工资高的员工信息select * from employee where salary &gt; any (select salary from employee where dept = (select id from dept where name = '研发部')); 行子查询返回的结果是一行（可以是多列）。常用操作符：=, &lt;, &gt;, IN, NOT IN 例子： 123-- 查询与xxx的薪资及直属领导相同的员工信息select * from employee where (salary, manager) = (12500, 1);select * from employee where (salary, manager) = (select salary, manager from employee where name = 'xxx'); 表子查询返回的结果是多行多列常用操作符：IN 例子： 1234-- 查询与xxx1，xxx2的职位和薪资相同的员工select * from employee where (job, salary) in (select job, salary from employee where name = 'xxx1' or name = 'xxx2');-- 查询入职日期是2006-01-01之后的员工，及其部门信息select e.*, d.* from (select * from employee where entrydate &gt; '2006-01-01') as e left join dept as d on e.dept = d.id; 事务事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。 基本操作： 1234567891011121314151617181920212223-- 1. 查询张三账户余额select * from account where name = '张三';-- 2. 将张三账户余额-1000update account set money = money - 1000 where name = '张三';-- 此语句出错后张三钱减少但是李四钱没有增加模拟sql语句错误-- 3. 将李四账户余额+1000update account set money = money + 1000 where name = '李四';-- 查看事务提交方式SELECT @@AUTOCOMMIT;-- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效SET @@AUTOCOMMIT = 0;-- 提交事务COMMIT;-- 回滚事务ROLLBACK;-- 设置手动提交后上面代码改为：select * from account where name = '张三';update account set money = money - 1000 where name = '张三';update account set money = money + 1000 where name = '李四';commit; 操作方式二： 开启事务：START TRANSACTION 或 BEGIN TRANSACTION;提交事务：COMMIT;回滚事务：ROLLBACK; 操作实例： 12345start transaction;select * from account where name = '张三';update account set money = money - 1000 where name = '张三';update account set money = money + 1000 where name = '李四';commit; 四大特性ACID 原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败 一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态 隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行 持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的 并发事务 问题 描述 脏读 一个事务读到另一个事务还没提交的数据 不可重复读 一个事务先后读取同一条记录，但两次读取的数据不同 幻读 一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在 这三个问题的详细演示：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd 并发事务隔离级别： 隔离级别 脏读 不可重复读 幻读 Read uncommitted √ √ √ Read committed × √ √ Repeatable Read(默认) × × √ Serializable × × × √表示在当前隔离级别下该问题会出现 Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差 查看事务隔离级别：SELECT @@TRANSACTION_ISOLATION;设置事务隔离级别：SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE };SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效 进阶篇存储引擎MySQL体系结构： 存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。默认存储引擎是InnoDB。 相关操作： 12345678-- 查询建表语句show create table account;-- 建表时指定存储引擎CREATE TABLE 表名( ...) ENGINE=INNODB;-- 查看当前数据库支持的存储引擎show engines; InnoDBInnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。 特点： DML 操作遵循 ACID 模型，支持事务 行级锁，提高并发访问性能 支持外键约束，保证数据的完整性和正确性 文件： xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。 参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间 知识点： 查看 Mysql 变量：show variables like 'innodb_file_per_table'; 从idb文件提取表结构数据：（在cmd运行）ibd2sdi xxx.ibd InnoDB 逻辑存储结构： MyISAMMyISAM 是 MySQL 早期的默认存储引擎。 特点： 不支持事务，不支持外键 支持表锁，不支持行锁 访问速度快 文件： xxx.sdi: 存储表结构信息 xxx.MYD: 存储数据 xxx.MYI: 存储索引 MemoryMemory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。 特点： 存放在内存中，速度快 hash索引（默认） 文件： xxx.sdi: 存储表结构信息 存储引擎特点 特点 InnoDB MyISAM Memory 存储限制 64TB 有 有 事务安全 支持 - - 锁机制 行锁 表锁 表锁 B+tree索引 支持 支持 支持 Hash索引 - - 支持 全文索引 支持（5.6版本之后） 支持 - 空间使用 高 低 N/A 内存使用 高 低 中等 批量插入速度 低 高 高 支持外键 支持 - - 存储引擎的选择在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。 InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择 MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。 Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性 电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。 性能分析查看执行频次查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：SHOW GLOBAL STATUS LIKE 'Com_______'; 或者 SHOW SESSION STATUS LIKE 'Com_______';例：show global status like 'Com_______' 慢查询日志慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息： # 开启慢查询日志开关 slow_query_log=1 # 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志 long_query_time=2更改后记得重启MySQL服务，日志文件位置：/var/lib/mysql/localhost-slow.log 查看慢查询日志开关状态：show variables like 'slow_query_log'; profileshow profile 能在做SQL优化时帮我们了解时间都耗费在哪里。通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：SELECT @@have_profiling;profiling 默认关闭，可以通过set语句在session/global级别开启 profiling：SET profiling = 1;查看所有语句的耗时：show profiles;查看指定query_id的SQL语句各个阶段的耗时：show profile for query query_id;查看指定query_id的SQL语句CPU的使用情况show profile cpu for query query_id; explainEXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。语法： # 直接在select语句之前加上关键字 explain / desc EXPLAIN SELECT 字段列表 FROM 表名 HWERE 条件; EXPLAIN 各字段含义： id：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行） select_type：表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等 type：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all possible_key：可能应用在这张表上的索引，一个或多个 Key：实际使用的索引，如果为 NULL，则没有使用索引 Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好 rows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的 filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好 索引索引是帮助 MySQL 高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。 优缺点： 优点： 提高数据检索效率，降低数据库的IO成本 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗 缺点： 索引列也是要占用空间的 索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE 索引结构 索引结构 描述 B+Tree 最常见的索引类型，大部分引擎都支持B+树索引 Hash 底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询 R-Tree(空间索引) 空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 Full-Text(全文索引) 是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES 索引 InnoDB MyISAM Memory B+Tree索引 支持 支持 支持 Hash索引 不支持 不支持 支持 R-Tree索引 不支持 支持 不支持 Full-text 5.6版本后支持 支持 不支持 B-Tree 二叉树的缺点可以用红黑树来解决：红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。 为了解决上述问题，可以使用 B-Tree 结构。B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针） B-Tree 的数据插入过程动画参照：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68演示地址：https://www.cs.usfca.edu/~galles/visualization/BTree.html B+Tree结构图： 演示地址：https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html 与 B-Tree 的区别： 所有的数据都会出现在叶子节点 叶子节点形成一个单向链表 MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。 Hash哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。 特点： Hash索引只能用于对等比较（=、in），不支持范围查询（betwwn、&gt;、&lt;、…） 无法利用索引完成排序操作 查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引 存储引擎支持： Memory InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的 面试题 为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？ 相对于二叉树，层级更少，搜索效率高 对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低 相对于 Hash 索引，B+Tree 支持范围匹配及排序操作 索引分类 分类 含义 特点 关键字 主键索引 针对于表中主键创建的索引 默认自动创建，只能有一个 PRIMARY 唯一索引 避免同一个表中某数据列中的值重复 可以有多个 UNIQUE 常规索引 快速定位特定数据 可以有多个 全文索引 全文索引查找的是文本中的关键词，而不是比较索引中的值 可以有多个 FULLTEXT 在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种： 分类 含义 特点 聚集索引(Clustered Index) 将数据存储与索引放一块，索引结构的叶子节点保存了行数据 必须有，而且只有一个 二级索引(Secondary Index) 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 可以存在多个 演示图： 聚集索引选取规则： 如果存在主键，主键索引就是聚集索引 如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引 如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引 思考题1. 以下 SQL 语句，哪个执行效率高？为什么？ 123select * from user where id = 10;select * from user where name = 'Arm';-- 备注：id为主键，name字段创建的有索引 答：第一条语句，因为第二条需要回表查询，相当于两个步骤。 2. InnoDB 主键索引的 B+Tree 高度为多少？ 答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.可得公式：n * 8 + (n + 1) * 6 = 16 * 1024，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。 如果树的高度为2，那么他能存储的数据量大概为：1171 * 16 = 18736；如果树的高度为3，那么他能存储的数据量大概为：1171 * 1171 * 16 = 21939856。 另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。 语法创建索引：CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引 查看索引：SHOW INDEX FROM table_name; 删除索引：DROP INDEX index_name ON table_name; 案例： 1234567891011-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引create index idx_user_name on tb_user(name);-- phone手机号字段的值非空，且唯一，为该字段创建唯一索引create unique index idx_user_phone on tb_user (phone);-- 为profession, age, status创建联合索引create index idx_user_pro_age_stat on tb_user(profession, age, status);-- 为email建立合适的索引来提升查询效率create index idx_user_email on tb_user(email);-- 删除索引drop index idx_user_email on tb_user; 使用规则最左前缀法则如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将部分失效（后面的字段索引失效）。 联合索引中，出现范围查询（&lt;, &gt;），范围查询右侧的列索引失效。可以用&gt;=或者&lt;=来规避索引失效问题。 索引失效情况 在索引列上进行运算操作，索引将失效。如：explain select * from tb_user where substring(phone, 10, 2) = '15'; 字符串类型字段使用时，不加引号，索引将失效。如：explain select * from tb_user where phone = 17799990015;，此处phone的值没有加引号 模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：explain select * from tb_user where profession like '%工程';，前后都有 % 也会失效。 用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。 如果 MySQL 评估使用索引比全表更慢，则不使用索引。 SQL 提示是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。 例如，使用索引：explain select * from tb_user use index(idx_user_pro) where profession=\"软件工程\";不使用哪个索引：explain select * from tb_user ignore index(idx_user_pro) where profession=\"软件工程\";必须使用哪个索引：explain select * from tb_user force index(idx_user_pro) where profession=\"软件工程\"; use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。 覆盖索引&amp;回表查询尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。 explain 中 extra 字段含义：using index condition：查找使用了索引，但是需要回表查询数据using where; using index;：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询 如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如select id, name from xxx where name='xxx';，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如select id, name, gender from xxx where name='xxx'; 所以尽量不要用select *，容易出现回表查询，降低效率，除非有联合索引包含了所有字段 面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：select id, username, password from tb_user where username='itcast'; 解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引 前缀索引当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。 语法：create index idx_xxxx on table_name(columnn(n));前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。求选择性公式： 12select count(distinct email) / count(*) from tb_user;select count(distinct substring(email, 1, 5)) / count(*) from tb_user; show index 里面的sub_part可以看到接取的长度 单列索引&amp;联合索引单列索引：即一个索引只包含单个列联合索引：即一个索引包含了多个列在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。 单列索引情况：explain select id, phone, name from tb_user where phone = '17799990010' and name = '韩信';这句只会用到phone索引字段 注意事项 多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询 设计原则 针对于数据量较大，且查询比较频繁的表建立索引 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高 如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询 SQL 优化插入数据普通插入： 采用批量插入（一次插入的数据不建议超过1000条） 手动提交事务 主键顺序插入 大批量插入：如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。 1234567# 客户端连接服务端时，加上参数 --local-infile（这一行在bash/cmd界面输入）mysql --local-infile -u root -p# 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关set global local_infile = 1;select @@local_infile;# 执行load指令将准备好的数据，加载到表结构中load data local infile '/root/sql1.log' into table 'tb_user' fields terminated by ',' lines terminated by '\\n'; 主键优化数据组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT） 页分裂：页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。页合并：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。 MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定 文字说明不够清晰明了，具体可以看视频里的PPT演示过程：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90 主键设计原则： 满足业务需求的情况下，尽量降低主键的长度 插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键 尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号 业务操作时，避免对主键的修改 order by优化 Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序 Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高 如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是Using index, Using filesort，如果要优化掉Using filesort，则需要另外再创建一个索引，如：create index idx_user_age_phone_ad on tb_user(age asc, phone desc);，此时使用select id, age, phone from tb_user order by age asc, phone desc;会全部走索引 总结： 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则 尽量使用覆盖索引 多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC） 如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k） group by优化 在分组操作时，可以通过索引来提高效率 分组操作时，索引的使用也是满足最左前缀法则的 如索引为idx_user_pro_age_stat，则句式可以是select ... where profession order by age，这样也符合最左前缀法则 limit优化常见的问题如limit 2000000, 10，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化 例如： 12345678-- 此语句耗时很长select * from tb_sku limit 9000000, 10;-- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询select id from tb_sku order by id limit 9000000, 10;-- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);-- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度select * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id = a.id; count优化MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高（前提是不适用where）；InnoDB 在执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用redis count的几种用法： 如果count函数的参数（count里面写的那个字段）不是NULL（字段值不为NULL），累计值就加一，最后返回累计值 用法：count(*)、count(主键)、count(字段)、count(1) count(主键)跟count(*)一样，因为主键不能为空；count(字段)只计算字段值不为NULL的行；count(1)引擎会为每行添加一个1，然后就count这个1，返回结果也跟count(*)一样；count(null)返回0 各种用法的性能： count(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空） count(字段)：没有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加 count(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加 count(*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加 按效率排序：count(字段) &lt; count(主键) &lt; count(1) &lt; count(*)，所以尽量使用 count(*) update优化（避免行锁升级为表锁）InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。 如以下两条语句：update student set no = '123' where id = 1;，这句由于id有主键索引，所以只会锁这一行；update student set no = '123' where name = 'test';，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引 数据类型整型 类型名称 取值范围 大小 TINYINT -128〜127 1个字节 SMALLINT -32768〜32767 2个宇节 MEDIUMINT -8388608〜8388607 3个字节 INT (INTEGHR) -2147483648〜2147483647 4个字节 BIGINT -9223372036854775808〜9223372036854775807 8个字节 无符号在数据类型后加 unsigned 关键字。 浮点型 类型名称 说明 存储需求 FLOAT 单精度浮点数 4 个字节 DOUBLE 双精度浮点数 8 个字节 DECIMAL (M, D)，DEC 压缩的“严格”定点数 M+2 个字节 日期和时间 类型名称 日期格式 日期范围 存储需求 YEAR YYYY 1901 ~ 2155 1 个字节 TIME HH:MM:SS -838:59:59 ~ 838:59:59 3 个字节 DATE YYYY-MM-DD 1000-01-01 ~ 9999-12-3 3 个字节 DATETIME YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 8 个字节 TIMESTAMP YYYY-MM-DD HH:MM:SS 1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC 4 个字节 字符串 类型名称 说明 存储需求 CHAR(M) 固定长度非二进制字符串 M 字节，1&lt;=M&lt;=255 VARCHAR(M) 变长非二进制字符串 L+1字节，在此，L&lt; = M和 1&lt;=M&lt;=255 TINYTEXT 非常小的非二进制字符串 L+1字节，在此，L&lt;2^8 TEXT 小的非二进制字符串 L+2字节，在此，L&lt;2^16 MEDIUMTEXT 中等大小的非二进制字符串 L+3字节，在此，L&lt;2^24 LONGTEXT 大的非二进制字符串 L+4字节，在此，L&lt;2^32 ENUM 枚举类型，只能有一个枚举字符串值 1或2个字节，取决于枚举值的数目 (最大值为65535) SET 一个设置，字符串对象可以有零个或 多个SET成员 1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员） 二进制类型 类型名称 说明 存储需求 BIT(M) 位字段类型 大约 (M+7)/8 字节 BINARY(M) 固定长度二进制字符串 M 字节 VARBINARY (M) 可变长度二进制字符串 M+1 字节 TINYBLOB (M) 非常小的BLOB L+1 字节，在此，L&lt;2^8 BLOB (M) 小 BLOB L+2 字节，在此，L&lt;2^16 MEDIUMBLOB (M) 中等大小的BLOB L+3 字节，在此，L&lt;2^24 LONGBLOB (M) 非常大的BLOB L+4 字节，在此，L&lt;2^32 权限一览表 具体权限的作用详见官方文档 GRANT 和 REVOKE 允许的静态权限 Privilege Grant Table Column Context ALL [PRIVILEGES] Synonym for “all privileges” Server administration ALTER Alter_priv Tables ALTER ROUTINE Alter_routine_priv Stored routines CREATE Create_priv Databases, tables, or indexes CREATE ROLE Create_role_priv Server administration CREATE ROUTINE Create_routine_priv Stored routines CREATE TABLESPACE Create_tablespace_priv Server administration CREATE TEMPORARY TABLES Create_tmp_table_priv Tables CREATE USER Create_user_priv Server administration CREATE VIEW Create_view_priv Views DELETE Delete_priv Tables DROP Drop_priv Databases, tables, or views DROP ROLE Drop_role_priv Server administration EVENT Event_priv Databases EXECUTE Execute_priv Stored routines FILE File_priv File access on server host GRANT OPTION Grant_priv Databases, tables, or stored routines INDEX Index_priv Tables INSERT Insert_priv Tables or columns LOCK TABLES Lock_tables_priv Databases PROCESS Process_priv Server administration PROXY See proxies_priv table Server administration REFERENCES References_priv Databases or tables RELOAD Reload_priv Server administration REPLICATION CLIENT Repl_client_priv Server administration REPLICATION SLAVE Repl_slave_priv Server administration SELECT Select_priv Tables or columns SHOW DATABASES Show_db_priv Server administration SHOW VIEW Show_view_priv Views SHUTDOWN Shutdown_priv Server administration SUPER Super_priv Server administration TRIGGER Trigger_priv Tables UPDATE Update_priv Tables or columns USAGE Synonym for “no privileges” Server administration GRANT 和 REVOKE 允许的动态权限 Privilege Context APPLICATION_PASSWORD_ADMIN Dual password administration AUDIT_ABORT_EXEMPT Allow queries blocked by audit log filter AUDIT_ADMIN Audit log administration AUTHENTICATION_POLICY_ADMIN Authentication administration BACKUP_ADMIN Backup administration BINLOG_ADMIN Backup and Replication administration BINLOG_ENCRYPTION_ADMIN Backup and Replication administration CLONE_ADMIN Clone administration CONNECTION_ADMIN Server administration ENCRYPTION_KEY_ADMIN Server administration FIREWALL_ADMIN Firewall administration FIREWALL_EXEMPT Firewall administration FIREWALL_USER Firewall administration FLUSH_OPTIMIZER_COSTS Server administration FLUSH_STATUS Server administration FLUSH_TABLES Server administration FLUSH_USER_RESOURCES Server administration GROUP_REPLICATION_ADMIN Replication administration GROUP_REPLICATION_STREAM Replication administration INNODB_REDO_LOG_ARCHIVE Redo log archiving administration NDB_STORED_USER NDB Cluster PASSWORDLESS_USER_ADMIN Authentication administration PERSIST_RO_VARIABLES_ADMIN Server administration REPLICATION_APPLIER PRIVILEGE_CHECKS_USER for a replication channel REPLICATION_SLAVE_ADMIN Replication administration RESOURCE_GROUP_ADMIN Resource group administration RESOURCE_GROUP_USER Resource group administration ROLE_ADMIN Server administration SESSION_VARIABLES_ADMIN Server administration SET_USER_ID Server administration SHOW_ROUTINE Server administration SYSTEM_USER Server administration SYSTEM_VARIABLES_ADMIN Server administration TABLE_ENCRYPTION_ADMIN Server administration VERSION_TOKEN_ADMIN Server administration XA_RECOVER_ADMIN Server administration 图形化界面工具 Workbench(免费): http://dev.mysql.com/downloads/workbench/ navicat(收费，试用版30天): https://www.navicat.com/en/download/navicat-for-mysql Sequel Pro(开源免费，仅支持Mac OS): http://www.sequelpro.com/ HeidiSQL(免费): http://www.heidisql.com/ phpMyAdmin(免费): https://www.phpmyadmin.net/ SQLyog: https://sqlyog.en.softonic.com/ 安装小技巧 在SQL语句之后加上\\G会将结果的表格形式转换成行文本形式 查看Mysql数据库占用空间：1234SELECT table_schema \"Database Name\" , SUM(data_length + index_length) / (1024 * 1024) \"Database Size in MB\"FROM information_schema.TABLESGROUP BY table_schema;","categories":[],"tags":[]},{"title":"8-24","slug":"8-12","date":"2023-09-18T02:49:50.353Z","updated":"2022-01-06T09:19:16.876Z","comments":true,"path":"2023/09/18/8-12/","link":"","permalink":"http://example.com/2023/09/18/8-12/","excerpt":"","text":"8-12 的笔记8-24来传 懂的都懂我又摸鱼了循环while（循环条件）{ 循环体；}循环条件会经过判断形成true和false来判断进不进行循环体的操作最简单的循环体就是true形成最简单的死循环 break：跳出当前循环；跳出switch——case循环break一般不单独使用跟if判断一起使用 为什么我while里面的东西一直写反啊 干do while循环遇见首先执行一遍循环 拿执行后的结果判断是不是要循环的用do-while循环do{ 循环体；}while（循环条件）；最少执行一遍循环体 **程序调试！！1、写完程序 想看程序的执行过程2、当你写完程序发现程序并没有按照想象样子执行 调试方法：1、F11逐语句调试2、F10逐过程调试3、断点调试","categories":[],"tags":[]},{"title":"古剑期间的c#(1)","slug":"8-11","date":"2023-09-18T02:49:50.345Z","updated":"2022-01-06T09:19:16.874Z","comments":true,"path":"2023/09/18/8-11/","link":"","permalink":"http://example.com/2023/09/18/8-11/","excerpt":"","text":"1.异常处理 try-catch ：try{ 可能出现异常的代码；}catch{ 出现异常之后要执行的代码；} 2.变量的作用域变量的作用域一般从声明的{}开始到这个括号的结束而结束 让代码满足某些条件去执行的话，使用bool类型 3.switch-case多条件的定值的判断：switch（变量或表达式的值）{ case 值1：要执行的代码； break； case 值2：要执行的代码； break； case 值3：要执行的代码； break； ……… default：要执行的代码； break；}switch后面的值要与值1、2、3的值是一样得 如果是字符串要加“” //有道题可以反复斟酌的//在8-10本地文件中","categories":[],"tags":[]},{"title":"无题","slug":"7.22","date":"2023-09-18T02:49:50.328Z","updated":"2022-01-06T09:19:16.872Z","comments":true,"path":"2023/09/18/7.22/","link":"","permalink":"http://example.com/2023/09/18/7.22/","excerpt":"","text":"遇到不想遇到的我唯一想到的只有赶紧走逃离这个镇回避各忆躲于角落纵使身旁人 不知何故对曰一眼可识两人即为影一拳可捶出吾 慌张姿态 两年成长似巨人各类知识灌脑看似冷静 且自信为此憾心振地我为为我愿我愿为了其未来生活离开 逃避他人眼中 吾不可为丈夫吾笑他 不懂社会复杂无能力不可有情无实力 不会有联系无钱财 不会有完美生活 转眼已拐入服饰店内我依旧是我她还是他 不忘 不见我怅然大笑眨眼 已是驾车远离天空很蓝 太阳很耀眼回想百种汹涌总有来由万般历练皆是生活","categories":[],"tags":[]},{"title":"我的新博客","slug":"我的新博客","date":"2023-09-15T07:02:22.000Z","updated":"2023-09-15T07:06:52.950Z","comments":true,"path":"2023/09/15/我的新博客/","link":"","permalink":"http://example.com/2023/09/15/%E6%88%91%E7%9A%84%E6%96%B0%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"第一章内容 markdown形式吼吼吼 之前的博客fdwjnzs.github.io","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-09-15T06:58:56.093Z","updated":"2023-09-15T06:58:56.093Z","comments":true,"path":"2023/09/15/hello-world/","link":"","permalink":"http://example.com/2023/09/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"2022-2-2 c#","slug":"2022-2-2","date":"2022-02-01T16:00:00.000Z","updated":"2022-02-03T13:01:43.217Z","comments":true,"path":"2022/02/02/2022-2-2/","link":"","permalink":"http://example.com/2022/02/02/2022-2-2/","excerpt":"","text":"字符串提供的各种方法（1）xxx.Length获得当前字符串中字符的个数（2）xxx.ToUpper()转换成大写 xxx.ToLower()转换成小写（3）xxx.Equals(YYY)意思是xxx与yyy比较是否相同 在yyy之后加入.StringComparation.OrdinalIgnoreCase比较可忽略大小写（4）字符串的分割定义一个string类型的字符串s，里面有+ - = 空格 abcd等字母先定义一个char[] chs={‘+’，‘ ’，‘-’，‘=’，‘，’}；把不需要的字符放进去这个时候string[] str=s.Split(chs);里面不需要的字符已经被干掉了，但是原来字符的位置都是空需要在chs之后添加参数StringSplitOptions.RemoveEmptyEntriesstring[] str=s.Split(chs,StringSplitOptions.RemoveEmptyEntries);就只剩下我们需要的acbd等字符了***但是我自己试了一下好像vs2019中自动默认去掉了空，不用参数直接就行！！！ 替换1234567string str = \"国家关键人物老习\"; if (str.Contains(\"习\")) { str = str.Replace(\"习\", \"***\"); } Console.WriteLine(str); Console.ReadKey(); Substring截取字符串1234string str = \"相见争如不见，有情还似无情\"; str = str.Substring(1, 3); Console.WriteLine(str); Console.ReadKey(); 这里1,3作为参数1代表第几个字符，3代表长度如上代码输出为 –&gt; 见争如 xxx.StartWith(“从哪个开始的数”);xxx.EndWith(“以哪个结束的数”);返回的bool类型，用以判断 xxx.IndexOf(‘要找的字符’,寻找的起始位置); 返回int类型的值 找不到返回-1xxx.LastIndexOf(‘出现在最后要找的字符’); 返回int类型的值 找不到返回-1 LastIndexOf与Substring12345string path = @\"c:\\a\\s\\d\\fd\\gfsfwe\\fwfw\\fdw.word\"; int index = path.LastIndexOf(\"\\\\\"); path = path.Substring(index + 1); Console.WriteLine(path); Console.ReadKey(); xxx.Trim()；用于去掉头和尾的空格xxx.TrimStart()；用于去掉头的空格xxx.TrimEnd()；用于去掉尾的空格string.IsNullOrEmpty(要判断的字符串)用于判断是否为空/nullstring.join（“用于分割的符号”,要处理的数组名或者将每个数组写进去因为是params）返回一个字符串 继承语法：子类名：父类名{ 方法体；}子类继承父类的属性和方法，不继承私有字段继承的特性：（1）单根型：一个子类只能有一个父类（2）传递性通常可以查看类图 比较清晰明了 子类没有继承父类的构造函数，但是子类会默认调用父类无参数的构造函数，创建父类的对象，来让子类可以使用父类中的成员在父类中写了一个有参数的构造函数，原来无参数的就被干掉了，调用不到，然后报错解决办法：1）在父类中重新写一个无参数的构造函数 2）用关键字：base（）直接调用父类中有参数的构造函数 new关键字1）创建对象2）隐藏从父类那里继承过来同名成员（子类调用不到父类的成员） 里氏转换1）子类可以赋值给父类：如果有一个地方需要一个父类作为参数，我们可以给一个子类代替student s=new student（）；person p =s；—–&gt;person p=new student（）；2）如果父类中装的是子类对象 那么可以将这个父类强转为子类对象student ss=（student）p；ss.SayHello();子类对象可以调用父类的成员，但是父类对象永远都只能调用自己的成员 is:表示类型转换，如果能够转换成功，返回true否则就是falseas：表示类型转换，如果能转换则返回对应的对象，否则返回一个null protected访问修饰符：可以在该类的内部以及该类的子类中进行访问 ArrayList数组：长度不可变，类型单一集合：长度可以任意改变，类型随便ArrayList list =new ArrayList（）;list.Add（任意类型,最好是单个元素） 用for循环输出 长度为list.count但是我们将一个对象打印到控制台，默认情况打印的是这个对象所在类的命名空间list.AddRange（添加集合元素）;list.Clear();移除所有元素list.Remove();移除单个元素，写谁删谁list.RemoveAt();根据下标删除元素list.RemoveRange();根据下标删除一定范围的元素list.Sort();升序排列list.Reverse();反转list.Insert(位置,元素);插入单个元素list.InsertRange(位置，集合);插入集合bool x=list.contains（）；是否包含某个指定的元素 ArrayList长度问题count：表示这个集合中实际包含元素的个数capacity：表示这个集合中可以包含元素的个数当count超过capacity，集合就会向内存申请多开辟一倍的空间，来保证集合的长度一直够用 hashtable键值对集合hashtable th=new hashtable（）；th.Add(键，值);th[键]=值；输出键值对循环需要用到foreach循环foreach（var item in xx）{ 方法体；} path类快速获得一个路径下文件的名字 Path.GetFileName();获得文件名但是不包含扩展名Path.GetFileNameWithoutExtension();直接获得文件的扩展名Path.GetExtension();获得文件所在的文件夹的名称Path.GetDirectoryName();获得文件所在的全路径Path.GetFullPath(); file类在某路径创建文件File.Create(@”路径\\文件名”);同理file.delete();复制一个文件File.Copy(@”路径\\文件名”,@”路径\\新文件名”);1024byte=1kb1024kb=1M1024M=1G1024G=1T1024T=1PT","categories":[],"tags":[]},{"title":"2022-2-1","slug":"2022-2-1","date":"2022-01-31T16:00:00.000Z","updated":"2022-02-01T16:07:47.969Z","comments":true,"path":"2022/02/01/2022-2-1/","link":"","permalink":"http://example.com/2022/02/01/2022-2-1/","excerpt":"","text":"假定s为string类型数组可以使用s.tochararray（）；将其改变为char类型的数组这样就可以修改一个string类型的部分值因为string类型可以看做是char类型的只读数组比如chs为新的char类型的字符但是这个时候s并没有改变 需要我们将字符数组转换成字符串s = new string（chs）；、这个时候s就改变了（这个东西没什么大用） 12345678910111213141516171819202122232425262728293031using System;using System.Linq;using System.Diagnostics;using System.Collections.Generic;using System.Text;namespace _2022_2_1{ class Program { static void Main(string[] args) { StringBuilder sb = new StringBuilder(); string str = null; Stopwatch sw = new Stopwatch(); sw.Start(); for (int i = 0; i &lt; 100000; i++) { //str += i; sb.Append(i); } sw.Stop(); Console.WriteLine(sw.Elapsed); Console.WriteLine(sb.ToString()); Console.ReadKey(); } }} 新年好","categories":[],"tags":[]},{"title":"2022-1-30","slug":"2022-1-30","date":"2022-01-29T16:00:00.000Z","updated":"2022-01-31T17:28:13.300Z","comments":true,"path":"2022/01/30/2022-1-30/","link":"","permalink":"http://example.com/2022/01/30/2022-1-30/","excerpt":"","text":"练习写一个ticket类，有一个距离属性（本属性只读，在构造方法中赋值）不能为负数，有一个价格属性，价格属性只读并且根据距离distance计算价格price（1元/公里） 1234567891011121314151617181920212223242526272829303132333435363738394041using System;using System.Collections.Generic;using System.Text;namespace _2022_1_30{ public class Ticket { private double _distance; public double Distance { get { return _distance; } } public Ticket(double distance) { if (distance &lt; 0) { distance = 0; } this._distance = distance; } private double _price; public double Price { get { if (_distance &gt; 0 &amp;&amp; _distance &lt;= 100) { return _distance * 1.0; } else if (_distance &gt; 100 &amp;&amp; _distance &lt;= 200) { return _distance * 0.95; } else if (_distance &gt; 200 &amp;&amp; _distance &lt;= 300) { return _distance * 0.9; } else { return _distance * 0.8; } } } public void Calculate() { Console.WriteLine(\"这次乘车需要花费{0}元\",Price); } }} 1234567891011121314using System;namespace _2022_1_30{ class Program { static void Main(string[] args) { Ticket car = new Ticket(198); car.Calculate(); Console.ReadKey(); } }} 命名空间用于解决类的重名问题，可以看做“类的文件夹”就类似于java的包如果没有此命名空间可以：1.鼠标点，提示方块2.alt+shift+f10 在一个项目中引用另一个项目的类1.添加引用2.引用命名空间 值类型和引用类型区别：1、值类型和引用类型在内存上存储的地方不一样2、在传递值类型和传递引用类型的时候，传递的方式不一样值类型：值传递，引用类型：引用传递值类型：int double bool decimal char enum struct引用类型：string 自定义类值类型存储在内存的栈当中引用类型存储在内存的堆当中 字符串的不可变性：给一个字符串重新赋值之后，老值并没销毁，而是开辟一个新的空间存储新值当程序结束之后，GC扫描整个程序，发现没有使用到的就会销毁GC=garbage collection垃圾回收器 ！！新年快乐！！ ！！祝大家虎年大吉 吧！！","categories":[],"tags":[]},{"title":"2022-1-29","slug":"2022-1-29","date":"2022-01-28T16:00:00.000Z","updated":"2022-01-29T16:25:31.457Z","comments":true,"path":"2022/01/29/2022-1-29/","link":"","permalink":"http://example.com/2022/01/29/2022-1-29/","excerpt":"","text":"静态与非静态区别：（1）在非静态类中，既可以有实例成员，也可以有静态成员（2）在调用实例成员的时候，需要使用对象名.实例成员; 在调用静态成员的时候，需要使用类名.静态成员名;总结：静态成员必须使用类名去调用，而实例成员使用对象名去调用 静态函数中只允许访问静态成员，不允许访问实例成员 实例函数中既可以使用静态成员，也可以使用实例成员 静态类中只允许出现静态成员，不允许出现实例成员使用：（1）如果你想要你的类当做一个工具类去使用，可以考虑将类写成静态类（console） （2）静态类在项目中资源共享 构造函数作用：帮助我们初始化对象（给对象的每个属性依次的赋值）构造函数是一个特殊的方法1）构造函数没有返回值，void也不写2）构造函数的名字要求与类名相同创建对象的时候会执行构造函数构造函数是可以用重载的 关键字new比如 Person A=new Person（）；new做了三件事（1）在内存中开辟空间（2）在开辟的空间中创建对象（3）调用对象的构造函数进行初始化对象 关键字this（1）代表当前类的对象（2）在类当中显示的调用本类的构造函数 ：this 析构函数~Student（）{ 方法体；}当程序结束的时候才执行一般是帮助我们释放资源~~","categories":[],"tags":[]},{"title":"2022-1-28","slug":"2022-1-28","date":"2022-01-27T16:00:00.000Z","updated":"2022-01-28T16:11:28.685Z","comments":true,"path":"2022/01/28/2022-1-28/","link":"","permalink":"http://example.com/2022/01/28/2022-1-28/","excerpt":"","text":"面向对象：意在写出一个通用的代码，屏蔽差异类就是个模子，确定了对象应该具有的属性和方法当我们创好一个类后，需要给这个对象的每个属性去赋值，我们管这个过程称之为对象的初始化 类语法：[public] class 类名{ 字段； 属性； 方法；}写完类需要创建对象，创建对象的过程称之为类的实例化使用关键字 newthis：当前这个类的对象类是不占内存的，对象（字段）是占内存的 属性属性的作用就是保护字段，对字段的赋值和取值进行限定属性的本质就是两个方法，一个是get（），一个是set（）既有get也有set称之为可读可写只有get称为只读只有set称为只写一般用属性给类的对象赋值，赋的值最后也是给到字段 访问修饰符public 公开的private：私有的 ，只能在当前类的内部进行访问","categories":[],"tags":[]},{"title":"硬核飞行棋","slug":"2022-1-24","date":"2022-01-23T16:00:00.000Z","updated":"2022-01-24T09:20:38.507Z","comments":true,"path":"2022/01/24/2022-1-24/","link":"","permalink":"http://example.com/2022/01/24/2022-1-24/","excerpt":"","text":"最近偷懒了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325using System;namespace feixingqi{ class Program { public static int[] Maps = new int[100]; //静态变量模拟全局变量 public static int[] PlayerPos = new int[2]; //声明一个静态数组用来存储玩家A与玩家B坐标 public static string[] PlayerNames = new string[2]; //存储两个玩家的姓名 public static bool[] Flags = new bool[2]; //两个玩家的标记 static void Main(string[] args) { GameShow(); #region 输入玩家姓名 Console.WriteLine(\"请输入玩家a的姓名\"); PlayerNames[0] = Console.ReadLine(); while (PlayerNames[0] == \"\") { Console.WriteLine(\"玩家a的姓名不能为空，请重新输入\"); PlayerNames[0] = Console.ReadLine(); } Console.WriteLine(\"请输入玩家b的姓名\"); PlayerNames[1] = Console.ReadLine(); while (PlayerNames[1] == \"\" || PlayerNames[1] == PlayerNames[0]) { if (PlayerNames[1] == \"\") { Console.WriteLine(\"玩家b的姓名不能为空，请重新输入\"); PlayerNames[1] = Console.ReadLine(); } else { Console.WriteLine(\"玩家b的姓名不能与玩家a的姓名相同，请重新输入\"); PlayerNames[1] = Console.ReadLine(); } } #endregion //玩家输入完姓名之后应该先清屏 Console.Clear();//清屏 GameShow(); Console.WriteLine(\"{0}的士兵用A表示\",PlayerNames[0]); Console.WriteLine(\"{0}的士兵用B表示\", PlayerNames[1]); //画地图之前应该先初始化地图 InitialMap(); DrawMap(); while (PlayerPos[0] &lt;99 &amp;&amp; PlayerPos[1] &lt; 99) { if (Flags[0] == false) { PlayGame(0); } else { Flags[0] = false; } if (PlayerPos[0] &gt;= 99) { Console.WriteLine(\"玩家{0}赢了\",PlayerNames[0]); break; } if (Flags[1] == false) { PlayGame(1); } { Flags[1] = false; } if (PlayerPos[1] &gt;= 99) { Console.WriteLine(\"玩家{0}赢了\", PlayerNames[1]); break; } }//while Console.ReadKey(); } /// &lt;summary&gt; /// 画游戏头 /// &lt;/summary&gt; public static void GameShow() { Console.ForegroundColor = ConsoleColor.Green; Console.WriteLine(\"*********************\"); Console.ForegroundColor = ConsoleColor.Yellow; Console.WriteLine(\"*********************\"); Console.ForegroundColor = ConsoleColor.DarkGray; Console.WriteLine(\"*********************\"); Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine(\"*****硬核飞行棋******\"); Console.ForegroundColor = ConsoleColor.Cyan; Console.WriteLine(\"*********************\"); Console.ForegroundColor = ConsoleColor.White; Console.WriteLine(\"*********************\"); Console.ForegroundColor = ConsoleColor.DarkBlue; Console.WriteLine(\"*********************\"); } /// &lt;summary&gt; /// 初始化地图 /// &lt;/summary&gt; public static void InitialMap() { int[] Luckyturn = { 6, 23, 40,55, 69, 83 }; for (int i = 0; i &lt; Luckyturn.Length; i++) { //int index = Luckyturn[i]; Maps[Luckyturn[i]] = 1; } int[] Landmine = { 5, 13, 17, 33, 38, 50, 64, 80, 94 }; for (int i = 0; i &lt; Landmine.Length; i++) { Maps[Landmine[i]] = 2; } int[] Pause = { 9, 27, 60, 93 }; for (int i = 0; i &lt; Pause.Length; i++) { Maps[Pause[i]] = 3; } int[] TimeTunnel = { 20, 25, 45, 63, 72, 88, 90 }; for (int i = 0; i &lt; TimeTunnel.Length; i++) { Maps[TimeTunnel[i]] = 4; } } public static void DrawMap() { Console.WriteLine(\"图例:幸运轮盘:◎ 地雷:☆ 暂停:▲ 时空隧道:卐\"); #region 第一横行 for (int i = 0; i &lt; 30; i++) { //玩家A与玩家B坐标相同，都在地图上，画一个尖括号 Console.Write(DrawStringMap(i)); }//for #endregion Console.WriteLine(); #region 第一竖行 for (int i = 30; i &lt; 35; i++) { for (int j = 0; j &lt;= 28; j++) { Console.Write(\" \"); } Console.Write(DrawStringMap(i)); Console.WriteLine(); } #endregion #region 第二横行 for (int i = 64; i &gt;= 35; i--) { Console.Write(DrawStringMap(i)); //画完第二横行应该换行 } #endregion Console.WriteLine(); #region 第二竖行 for (int i = 65; i &lt;=69; i++) { Console.WriteLine(DrawStringMap(i)); } #endregion #region 第三横行 for (int i = 70; i &lt;=99; i++) { Console.Write(DrawStringMap(i)); } #endregion //画完最后一行，应该换行 Console.WriteLine(); } /// &lt;summary&gt; /// 从画地图中抽象出来的一个方法 /// &lt;/summary&gt; /// &lt;param name=\"i\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string DrawStringMap(int i) { string str = \"\"; if (PlayerPos[0] == PlayerPos[1] &amp;&amp; PlayerPos[1] == i) { Console.ForegroundColor = ConsoleColor.DarkYellow; str = \"&lt;&gt;\"; } else if (PlayerPos[0] == i) { str = \"A\"; } else if (PlayerPos[1] == i) { str = \"B\"; } else { switch (Maps[i]) { case 0: Console.ForegroundColor = ConsoleColor.Red; str = \"□\"; break; case 1: Console.ForegroundColor = ConsoleColor.DarkMagenta; str = \"◎\"; break; case 2: Console.ForegroundColor = ConsoleColor.DarkRed; str = \"☆\"; break; case 3: Console.ForegroundColor = ConsoleColor.Yellow; str = \"▲\"; break; case 4: Console.ForegroundColor = ConsoleColor.Green; str = \"卐\"; break; }//switch }//else return str; } /// &lt;summary&gt; /// 玩游戏 /// &lt;/summary&gt; public static void PlayGame(int PlayerNumber) { Random r = new Random(); int rNumber = r.Next(1, 7); Console.WriteLine(\"{0}按任意键开始掷骰子\", PlayerNames[PlayerNumber]); Console.ReadKey(true); Console.WriteLine(\"{0}掷出了{1}\", PlayerNames[PlayerNumber], rNumber); PlayerPos[PlayerNumber] += rNumber; ChangePos(); Console.ReadKey(true); Console.WriteLine(\"{0}按任意键开始行动\", PlayerNames[PlayerNumber]); Console.ReadKey(true); Console.WriteLine(\"{0}行动完了\", PlayerNames[PlayerNumber]); Console.ReadKey(true); //玩家a可能踩到玩家b，方块 幸运轮盘 地雷 暂停 时空隧道 if (PlayerPos[PlayerNumber] == PlayerPos[1- PlayerNumber]) { Console.WriteLine(\"玩家{0}踩到了玩家{1},玩家{2}退六格\", PlayerPos[PlayerNumber], PlayerPos[1- PlayerNumber], PlayerPos[1- PlayerNumber]); PlayerPos[1- PlayerNumber] -= 6; ChangePos(); Console.ReadKey(true); } else { switch (Maps[PlayerPos[PlayerNumber]]) { case 0: Console.WriteLine(\"玩家{0}踩到了方块，安全\", PlayerNames[PlayerNumber]); Console.ReadKey(); break; case 1: Console.WriteLine(\"玩家{0}踩到了幸运轮盘，1--交换位置，2--轰炸对方，退六格\", PlayerNames[PlayerNumber]); string input = Console.ReadLine(); while (true) { if (input == \"1\") { Console.WriteLine(\"玩家{0}选择跟玩家{1}交换位置\", PlayerNames[PlayerNumber], PlayerNames[1- PlayerNumber]); Console.ReadKey(true); int temp = PlayerPos[PlayerNumber]; PlayerPos[PlayerNumber] = PlayerPos[1- PlayerNumber]; PlayerPos[1- PlayerNumber] = temp; Console.WriteLine(\"交换成功,按任意键继续游戏\"); Console.ReadKey(true); break; } else if (input == \"2\") { Console.WriteLine(\"玩家{0}选择轰炸玩家{1}，玩家{2}退六格\", PlayerNames[PlayerNumber], PlayerNames[1- PlayerNumber], PlayerNames[1- PlayerNumber]); Console.ReadKey(true); PlayerPos[1- PlayerNumber] -= 6; ChangePos(); Console.WriteLine(\"玩家{0}退了六格\", PlayerNames[1-PlayerNumber]); Console.ReadKey(true); break; } else { Console.WriteLine(\"只能输入1和2，1--交换位置，2--轰炸对方，退六格,请重新输入\"); input = Console.ReadLine(); } } break; case 2: Console.WriteLine(\"玩家{0}踩到了地雷，退六格\", PlayerNames[PlayerNumber]); Console.ReadKey(true); PlayerPos[PlayerNumber] -= 6; ChangePos(); break; case 3: Console.WriteLine(\"玩家{0}踩到了暂停，暂停一回合\", PlayerNames[PlayerNumber]); Flags[PlayerNumber] = true; Console.ReadKey(true); break; case 4: Console.WriteLine(\"玩家{0}踩到了时空隧道，前进十格\", PlayerNames[PlayerNumber]); PlayerPos[PlayerNumber] += 10; ChangePos(); Console.ReadKey(true); break; }//switch }//else ChangePos(); Console.Clear(); DrawMap(); } /// &lt;summary&gt; /// 当玩家的坐标发生改变的时候调用 /// &lt;/summary&gt; public static void ChangePos() { if (PlayerPos[0] &lt; 0) { PlayerPos[0] = 0; } if (PlayerPos[0] &gt;= 99) { PlayerPos[0] = 99; } if (PlayerPos[1] &lt; 0) { PlayerPos[1] = 0; } if (PlayerPos[1] &gt;= 99) { PlayerPos[1] = 99; } } }}//□◎☆▲卐 拿去复制","categories":[],"tags":[]},{"title":"2022-1-8","slug":"2022-1-8","date":"2022-01-07T16:00:00.000Z","updated":"2022-01-24T09:15:41.799Z","comments":true,"path":"2022/01/08/2022-1-8/","link":"","permalink":"http://example.com/2022/01/08/2022-1-8/","excerpt":"","text":"写一个跟try-parse一样性质的方法12345678910111213141516171819202122232425262728namespace _2022_2_3{ class Program { static void Main(string[] args) { int num; bool b = int.TryParse(\"123\", out num); Console.WriteLine(num); Console.WriteLine(b); Console.ReadKey(); } public static bool MyTryParse(string s,out int result) { result = 0; try { result = Convert.ToInt32(s); return true; } catch { return false; } } }} ref参数能够将一个变量带入一个方法中进行改变改变完成后，能将改变后的数带出方法参数要求在方法外必须为其赋值，而方法内可以不赋值 ref参数练习使用方法交换两个int类型的变量 12345678910111213141516171819202122232425namespace _2022_2_3{ class Program { static void Main(string[] args) { int n1 = 10; int n2 = 20; Change(ref n1,ref n2); Console.WriteLine(\"{0}，{1}\",n1,n2); } /// &lt;summary&gt; /// 交换两个int类型的数 /// &lt;/summary&gt; /// &lt;param name=\"n1\"&gt;第一个数&lt;/param&gt; /// &lt;param name=\"n2\"&gt;第二个数&lt;/param&gt; public static void Change(ref int n1,ref int n2) { n1 = n1 - n2; n2 = n1 + n2; n1 = n2 - n1; } }} params可变参数将实参列表中跟可变参数数组类型一致的元素都当做数组的元素来处理params可变参数必须是形参类表中最后一个元素具有唯一性 params参数练习求任意长度数组的和 整数类型的 1234567891011121314151617181920212223using System;namespace _2022_1_6{ class Program { static void Main(string[] args) { int sum = GetSum(1, 2, 3, 4, 5); Console.WriteLine(sum); } public static int GetSum(params int[] n) { int sum = 0; for (int i = 0; i &lt; n.Length; i++) { sum += n[i]; } return sum; } }} 方法的重载方法的重载指的是方法的名称相同但是方法的参数不同分两种情况：参数个数相同，参数类型就不能相同 参数类型相同，参数个数就不能相同跟方法的返回值无关 方法的递归：方法自己调用自己方法的总和练习提示用户输入两个数字，计算这两个数字之间所有整数的和1用户只能输入数字2计算两个数字之间的和3要求第一个数字必须比第二个数字小，就重新输入 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970using System;namespace _2022_1_8{ class Program { static void Main(string[] args) { //提示用户输入两个数字，计算这两个数字之间所有整数的和 //1用户只能输入数字 //2计算两个数字之间的和 //3要求第一个数字必须比第二个数字小，就重新输入 Console.WriteLine(\"请输入第一个数\"); string NumberOne = Console.ReadLine(); int numberone = GetNumber(NumberOne); Console.WriteLine(\"请输入第二个数\"); string NumberTwo = Console.ReadLine(); int numbertwo = GetNumber(NumberTwo); JudgeNumber(ref numberone, ref numbertwo); int sum = GetSum(numberone, numbertwo); Console.WriteLine(sum); Console.ReadKey(); } public static int GetNumber(string s) { while (true) { try { int number = Convert.ToInt32(s); return number; } catch { Console.WriteLine(\"输入有误！！请重新输入数字\"); s = Console.ReadLine(); } } } public static void JudgeNumber(ref int n1,ref int n2) { while (true) { if (n1 &lt; n2) { return; } else { Console.WriteLine(\"第一个数字不能大于第二个数字，请重新输入\"); string s1 = Console.ReadLine(); n1 = GetNumber(s1); Console.WriteLine(\"请重新输入第二个数字\"); string s2 = Console.ReadLine(); n2 = GetNumber(s2); } } } public static int GetSum(int n1,int n2) { int sum = 0; for (int i = n1; i &lt;= n2; i++) { sum += i; } return sum; } }}","categories":[],"tags":[]},{"title":"2022-1-8","slug":"2022-1-9","date":"2022-01-07T16:00:00.000Z","updated":"2022-01-24T09:13:55.456Z","comments":true,"path":"2022/01/08/2022-1-9/","link":"","permalink":"http://example.com/2022/01/08/2022-1-9/","excerpt":"","text":"方法练习1用方法来实现：有一个字符串数组{“马龙”，“迈克尔乔丹”，“雷吉米勒”，“蒂姆邓肯”，“科比布莱恩特”}请输出最长的字符串 123456789101112131415161718192021222324252627282930namespace _2022_1_8{ class Program { static void Main(string[] args) { string[] name = {\"马龙\",\"迈克尔乔丹\",\"雷吉米勒\",\"蒂姆邓肯\",\"科比布莱恩特\"}; int MaxLenth = GetLength(name); System.Console.WriteLine(MaxLenth); } /// &lt;summary&gt; /// 求一个数组中字符串最长的长度 /// &lt;/summary&gt; /// &lt;param name=\"name\"&gt;数组名&lt;/param&gt; /// &lt;returns&gt;最长长度&lt;/returns&gt; public static int GetLength(string[] name) { string MaxLength = name[0]; for (int i = 0; i &lt; name.Length; i++) { if (name[i].Length &gt; MaxLength.Length) { MaxLength= name[i]; } } return MaxLength.Length; } }} 方法练习2请计算出一个整数数组的平均值，保留两位小数 1234567891011121314151617181920212223242526using System;namespace _2022_1_8{ class Program { static void Main(string[] args) { int[] Number = { 1, 2, 7 }; double Eve = GetEve(Number); string s = Eve.ToString(\"0.00\"); Eve = Convert.ToDouble(s); Console.WriteLine(Eve); } public static double GetEve(int[] Number) { double sum = 0; for (int i = 0; i &lt; Number.Length; i++) { sum += Number[i]; } return sum / Number.Length; } }} 方法练习3接受输入后判断其等级判断依据如下：等级优90-100，等级亮80-89 1234567891011121314151617181920212223242526272829using System;namespace _2022_1_9{ class Program { static void Main(string[] args) { Console.WriteLine(\"请输入考试成绩\"); int score = Convert.ToInt32(Console.ReadLine()); string level = GetLevel(score); Console.WriteLine(\"考试等地为{0}\", level); } public static string GetLevel(int score) { string level = \"\"; switch (score / 10) { case 10: case 9: level = \"优\"; break; case 8: level = \"良\"; break; case 7: case 6: level = \"合格\"; break; default: level = \"不合格\"; break; } return level; } } } 方法练习4反串字符串数组循环数组.length/2次for中循环体{ string temp=name[i]; names[i]=names[names.length-1-i]; names[names.length.length-1-i]=temp;}循环输出；方法二：array.revers（数组名） 方法练习5写一个方法，计算圆的面积和周长 12345678910111213141516171819202122using System;namespace _2022_1_9{ class Program { static void Main(string[] args) { //写一个方法，计算圆的面积和周长 Console.WriteLine(\"请输入圆的半径长\"); double r = Convert.ToDouble(Console.ReadLine()); double S, C; SandC(r, out S, out C); Console.WriteLine(\"面积为{0}，周长为{1}\",S,C); } public static void SandC(double r,out double S,out double C) { S = 3.14 * r * r; C = 2 * 3.14 * r; } }} 计算任意多个数间最大值 1234567891011121314151617181920212223namespace _2022_1_9{ class Program { static void Main(string[] args) { double Max=GetMax(1, 2, 3, 4, 5, 6); Console.WriteLine(Max); } public static double GetMax(params double[] n) { double Max = n[0]; for (int i = 0; i &lt; n.Length; i++) { if (n[i] &gt; Max) { Max = n[i]; } } return Max; } }} 通过冒泡排序对数组进行升序排序 123456789101112131415161718192021222324252627282930313233using System;namespace _2022_1_9{ class Program { static void Main(string[] args) { int[] nums = { 1, 3, 5, 7, 90, 2, 4, 6, 8, 10 }; Change(nums); for (int i = 0; i &lt; nums.Length; i++) { Console.WriteLine(nums[i]); } } public static void Change(int[] nums) { for (int i = 0; i &lt; nums.Length-1; i++) { for (int j = 0; j &lt; nums.Length-1-i; j++) { if (nums[j] &gt; nums[j + 1]) { int temp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = temp; } } } } }}","categories":[],"tags":[]},{"title":"今天也是充满希望的一天","slug":"2022-1-3","date":"2022-01-02T16:00:00.000Z","updated":"2022-01-24T09:16:15.542Z","comments":true,"path":"2022/01/03/2022-1-3/","link":"","permalink":"http://example.com/2022/01/03/2022-1-3/","excerpt":"","text":"c#中没有全局变量这个东西但是我们可以通过静态字段来模拟全局变量从而达到函数能获取main函数中的变量 练习1读取输入的整数，定义成方法多次调用（如果用户输入的是数字，则返回，否则提示重新输入）*方法对的功能一定要单一！！*方法中最忌讳的就是提示用户输入的字眼 1234567891011121314151617181920212223242526272829303132333435363738using System;namespace _2022_2_3{ class Program { static void Main(string[] args) { Console.WriteLine(\"请输入一个数字\"); string input = Console.ReadLine(); int result = Get(input); Console.WriteLine(result); Console.ReadKey(); } /// &lt;summary&gt; /// 这个方法需要判断用户输入是不是数字 /// 如果用户输入的是数字，则返回，否则提示重新输入 /// &lt;/summary&gt; /// &lt;param name=\"num\"&gt;输入的数字&lt;/param&gt; /// &lt;returns&gt;返回值&lt;/returns&gt; public static int Get(string s) { while (true) { try { int number = Convert.ToInt32(s); return number; } catch { Console.WriteLine(\"请重新输入\"); s = Console.ReadLine(); } } } }} 练习2只能让用户输入yes或者no，如果不是就重新输入 123456789101112131415161718192021222324252627282930313233343536using System;namespace _2022_2_3{ class Program { static void Main(string[] args) { Console.WriteLine(\"请输入yes或者no\"); string answer = Console.ReadLine(); string ANSWER = GetAnswer(answer); Console.WriteLine(ANSWER); Console.ReadKey(); } /// &lt;summary&gt; /// 限定用户只能输入yes或者no /// &lt;/summary&gt; /// &lt;param name=\"answer\"&gt;yes或者no&lt;/param&gt; /// &lt;returns&gt;用户输入的结果&lt;/returns&gt; public static string GetAnswer(string answer) { while (true) { if (answer == \"yes\" || answer == \"no\") { return answer; } else { Console.WriteLine(\"请重新输入\"); answer = Console.ReadLine(); } } } }} 练习3计算输入数组的和 123456789101112131415161718192021222324252627namespace _2022_2_3{ class Program { static void Main(string[] args) { int[] num = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; int sum = Plus(num); Console.WriteLine(sum); Console.ReadKey(); } /// &lt;summary&gt; /// 计算一个整数类型数组的总和，并返回总和值 /// &lt;/summary&gt; /// &lt;param name=\"num\"&gt;要求总和的数组&lt;/param&gt; /// &lt;returns&gt;总和值&lt;/returns&gt; public static int Plus(int[] num) { int sum = 0; for (int i = 0; i &lt; num.Length; i++) { sum += num[i]; } return sum; } }} 高级参数out参数：侧重于在一个方法中返回多个不同类型的值（如果你在一个方法中，返回多个相同类型的值的时候，可以考虑返回一个数组但是如果返回多个不同类型的值的时候，就不行了，这个时候可以考虑使用out参数） out类型练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748namespace _2022_2_3{ class Program { static void Main(string[] args) { Console.WriteLine(\"请输入您的用户名\"); string name = Console.ReadLine(); Console.WriteLine(\"请输入您的密码\"); string pwd = Console.ReadLine(); string msg; bool result = IsLogin(name, pwd, out msg); Console.WriteLine(\"登录结果{0}\",result); Console.WriteLine(\"登录信息{0}\",msg); Console.ReadKey(); } /// &lt;summary&gt; /// 判断登录是否成功 /// &lt;/summary&gt; /// &lt;param name=\"name\"&gt;用户名&lt;/param&gt; /// &lt;param name=\"pwd\"&gt;密码&lt;/param&gt; /// &lt;param name=\"msg\"&gt;提示信息&lt;/param&gt; /// &lt;returns&gt;登录状态提示&lt;/returns&gt; public static bool IsLogin(string name, string pwd ,out string msg) { if (name == \"admin\" &amp;&amp; pwd == \"888888\") { msg = \"登录成功！\"; return true; } else if (name == \"admin\") { msg = \"密码错误\"; return false; } else if(pwd == \"888888\") { msg = \"用户名错误\"; return false; } else { msg = \"未知错误\"; return false; } } }} 去放松一会","categories":[],"tags":[]},{"title":"今天你睡饱了吗①","slug":"2022-1-2","date":"2022-01-01T16:00:00.000Z","updated":"2022-01-24T09:16:48.407Z","comments":true,"path":"2022/01/02/2022-1-2/","link":"","permalink":"http://example.com/2022/01/02/2022-1-2/","excerpt":"","text":"困想着放假调个正常点的作息，昨天硬是到5点没睡着，我现在是一会一个哈欠一会一个，困死了今天是2022年第二天，冲下面是数组的三个练习 数组练习1数组中都是人名，（老杨，老苏，老邹，老虎，老牛，老马）要分割成–&gt;老杨|老苏|老邹|老虎|老牛|老马思路：通过循环，获取每个元素，都累加到字符串中，用|分割 12345678910111213141516171819using System;namespace _2022_1_2{ class Program { static void Main(string[] args) { string[] names = { \"老杨\", \"老苏\", \"老邹\", \"老虎\", \"老牛\", \"老马\" }; string str = null; for (int i = 0; i &lt; names.Length-1; i++) { str += names[i]+\"|\"; } Console.WriteLine(str+names[names.Length-1]); Console.ReadKey(); } }} 数组练习2将一个整数数组每一个元素进行如下处理如果元素为正数，这个位置元素值加一如果元素为负数，这个位置元素值减一，如果元素为0，则不变解题思路：不会去买块豆腐 12345678910111213141516171819202122232425262728using System;namespace _2022_1_2{ class Program { static void Main(string[] args) { int[] nums = { 1, -2, 3, -4, 5, 6, 0 }; for (int i = 0; i &lt; nums.Length; i++) { if (nums[i] &gt; 0) { nums[i] += 1; } else if (nums[i] &lt; 0) { nums[i] -= 1; } else { nums[i] = 0; } Console.WriteLine(nums[i]); } } }} 数组练习3~将一个数组中元素进行翻转{“我”，“是”，“好人”}-&gt;{“好人”，“是”，“我”}解题思路：*让下标为i的元素与下标为length-1-i的元素交换 12345678910111213141516171819202122using System;namespace _2022_1_2{ class Program { static void Main(string[] args) { string[] names = { \"我\", \"是\", \"好人\" }; for (int i = 0; i &lt; names.Length/2; i++) { string mid = names[i]; names[i] = names[names.Length - 1 - i]; names[names.Length - 1 - i] = mid; } for (int i = 0; i &lt; names.Length; i++) { Console.WriteLine(names[i]); } } }} 冒泡排序：将数组中元素按从大到小或从小到大的顺序进行排序排序：从第一个元素开始，与后面每个元素进行比较，直到比较完，到第二个元素…. 123456789101112for (int i = 0; i &lt; nums.Length-1; i++) { for (int j = 0; j &lt; nums.Length-1-i; j++) { if (nums[j] &gt; nums[j + 1]) { int mid = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = mid; } } } 此为升序排列 如果要降序排序 &gt; 改为&lt;号C#中可以代替排序的代码：Array.Sort（nums）;//只能实现升序 Array.Reverse(nums);//倒叙排序 方法（函数）函数的语法：[public] static 返回值类型 方法名 （[参数列表]）{ 方法体；}方法写完要在main函数中调用调用语法：类名.方法名（[参数]）某些情况下类名是可以省略的，如果写的方法与main函数同在一个类中，可以省略的 常量const int num =10；不许重新赋值","categories":[],"tags":[]},{"title":"新年第一天（2）","slug":"1-1","date":"2021-12-31T16:00:00.000Z","updated":"2022-01-06T09:19:16.864Z","comments":true,"path":"2022/01/01/1-1/","link":"","permalink":"http://example.com/2022/01/01/1-1/","excerpt":"","text":"接今天早上的写变量只能存一个值，而字段能存多个值字段在规则上要在命名前加上_(下划线) 俩简单例子：//using System; //namespace _2022_1_1//{// public struct Person// {// public string _name;// public int _age;// public Gender _gender;// }// public enum Gender// {// 男,// 女// } // class Program// {// static void Main(string[] args)// { //定义一个结构类型Person，有三个成员，分别是姓名，性别，年龄，性别用枚举类型 //声明两个Person类型的变量，分别表示张三男18岁，小兰女16岁// Person zsPerson;// zsPerson._name = “张三”;// zsPerson._age = 18;// zsPerson._gender = Gender.男; // Person xlPerson;// xlPerson._name = “小兰”;// xlPerson._age = 16;// xlPerson._gender = Gender.女; // Console.WriteLine(“{0}，{1}，{2}”, zsPerson._name, zsPerson._age, zsPerson._gender);// Console.WriteLine(“{0}，{1}，{2}”, xlPerson._name, xlPerson._age, xlPerson._gender);// }// }//}//using System; //namespace _2022_1_1//{ // public struct MyColor// {// public int _red;// public int _green;// public int _blue; // }// class Program// {// static void Main(string[] args)// {//定义一个结构叫MyColor，有三个成员，分别定义为int类型的red，green，blue//声明一个MyColor类型的变量，并对其成员赋值，使MyColor可以表示成一个红色//首先要搞清楚红绿蓝是三原色，一切的颜色都可以通过红绿蓝从0-255表示出来// MyColor mc;// mc._red = 255;// mc._blue = 0;// mc._green = 0;// Console.WriteLine(“{0}”,mc);// Console.ReadKey();// }// }//} 数组一次性存储多个相同类型的变量（结构是存储不同）语法：数组类型[] 数组名=new 数组类型[数组长度]；数组长度一旦固定了，就不能再被改变了int数组不赋值 默认为0string数组不赋值 默认为 null（null不是空，表示为开空间）bool数组不赋值 默认为false数组的声明方式int [] nums={1,2,4,5};要不就是从[0]开始一个一个循环赋值还有int [] nums=new int[3] {1,2,3};(不推荐)还有int [] nums =new int[] {1,2,3};(不推荐) 数组的应用/练习using System; namespace jichu{ class Program { static void Main(string[] args) { //练习1，从整数数组中取出最大的整数，最小整数，总和，平均值 int[] nums = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 }; int max = int.MinValue;//nums[0]; int min = int.MaxValue;//nums[0]; int sum = 0; for (int i = 0; i &lt; nums.Length; i++) { if (nums[i] &gt; max) { max = nums[i]; } if (nums[i] &lt; min) { min = nums[i]; } sum += nums[i]; } Console.WriteLine(“这个数组的最大值是{0},最小值是{1},总和为{2},平均数是{3}”,max,min,sum,sum/nums.Length); Console.ReadKey(); } }} c#内容就写到这里了这里我就不装了，2022-1-1曼城2-1逆转阿森纳虽然赛程密集，但是这场左后卫的阿克真的不适应这个位置和左边锋的斯特林没有任何配合导致b席和丁丁得回撤到后场拿球，更何况曼城是著名的无锋阵，没有支点，致使阿森纳从全场看下来都是更加优秀的一边关于点球和两黄变一红，我觉得没得洗，两强相遇，更加兴奋的球队更能占据主动，把握场上局势阿森纳确实做得好，但是越兴奋越容易上头，把握不好自己的情绪就是拿红牌下去的主要原因这场踢阿森纳确实如瓜瓜所说进5年内最强的阿森纳，确实未来可期但是我的主队还是曼城，罗德里最后时刻的绝杀太帅了，这场的3分实在是太关键了是这个赛季英超冠军上比较关键的一场了，gooooooal~~ 我这个寒假尽量做到天天写blog好吧，也是督促我自己早点掌握c#和u3d今天还是1月1号，祝朋友们恭喜发财，万事顺意，再见！","categories":[],"tags":[]},{"title":"新年第一天","slug":"2022","date":"2021-12-31T16:00:00.000Z","updated":"2022-01-24T09:17:10.315Z","comments":true,"path":"2022/01/01/2022/","link":"","permalink":"http://example.com/2022/01/01/2022/","excerpt":"","text":"枚举与别的类型之间的转换枚举类型默认是跟int可以转换复习一哈 强制类型转换int n=待转换的类型（要转换的值）例：(int 强制转换成枚举类型)QQstate state=QQstate.Online;int n =（int）state （枚举类型强转int类型）int n1=3；QQstate state=（QQstate）n1；console.writeline(state);console.readkey();复习：折叠不想看到的内容 #region #endregion *所有类型都能转换成string类型 用tostring例：int n1=10;doubledecimal都行string s =n1.ToString();console.writeline(s);console.readkey();结果为10例：（枚举-&gt;string）QQstate state =QQstate.online;string s =state.ToString();console.writeline(s);console.readkey(); *将字符串转换成枚举类型回忆一下：convert.toint32()所以这里要用到Enum.parse（）；例：string s =”0”;QQstate state =(QQstate)Enum.parse(typeof(QQstate),s);console.writeline(state);console.readkey();输出值为枚举第一个值总结：枚举类型默认是与int兼容，可通过强转相互转换当转换枚举中没有的值时，不抛异常，直接显示数字同样也能与string转换，如果枚举转换成string，直接用tostring如果将string转换成枚举要用一下代码：（要转换的枚举类型）Enum.Parse(typeof（要转换的枚举类型），“要转换的字符转”)；转换的是数字，枚举没有，不抛异常转换为文本，枚举中没有，抛异常 这里有个简单的练习 123456789101112131415161718192021222324252627282930313233343536373839404142434445namespace _2021_12_30{ // public enum gender //{ // 男, // 女 //} public enum state{//state这里首字母都要大写，要求 online=1, offline, leave, busy, qMe } class Program { static void Main(string[] args) { //int n = 10; //gender gender = gender.男; //Console.WriteLine(\"Hello World!\"); //提示用户输入一个在线状态，我们接收，将输入转换成枚举类型，再打印到控制台中 Console.WriteLine(\"请输入您的在线状态,1--online 2--offline 3--leave 4--busy 5--qMe\"); string input = Console.ReadLine(); switch (input) { case \"1\": state s1 = (state)Enum.Parse(typeof(state), input); Console.WriteLine(\"您选择的在线状态是{0}\",s1); break; case \"2\": state s2 = (state)Enum.Parse(typeof(state), input); Console.WriteLine(\"您选择的在线状态是{0}\",s2); break; case \"3\": state s3 = (state)Enum.Parse(typeof(state), input); Console.WriteLine(\"您选择的在线状态是{0}\",s3); break; case \"4\": state s4 = (state)Enum.Parse(typeof(state), input); Console.WriteLine(\"您选择的在线状态是{0}\", s4); break; case \"5\":state s5 = (state)Enum.Parse(typeof(state), input); Console.WriteLine(\"您选择的在线状态是{0}\", s5); break; } } }} 结构：可以帮助我们一次性声明多个不同类型的变量语法：[public] struct 结构名（这里跟enum一样结构名首字母要大写）{ 成员；} 今天是2022年1月1日，希望把去年不开心的忘记新的一年发发出传奇，叮叮都能振到刀，u3d学习顺利，考研顺利，找到个npy祝我身边的朋友身体健康，事事顺心","categories":[],"tags":[]},{"title":"今天比较有空","slug":"10-22","date":"2021-10-21T16:00:00.000Z","updated":"2022-01-06T09:19:16.862Z","comments":true,"path":"2021/10/22/10-22/","link":"","permalink":"http://example.com/2021/10/22/10-22/","excerpt":"","text":"开学也是过了很久，主要就是记录一下这一段时间发生了什么虽然这个学期的课不是很多，懂的都懂，毕竟很蛮多线上课的但为什么不想写呢，主要还是我懒 首先就是这个东西哇这个东西真的没有必要，没有之前心心念念，有了之后么基本就是没怎么玩过花几千块真的不值，还不如多搓几顿，现在我把它跟我的零食放在一起，也算每天还能碰到两下不会落下什么灰。如果对VR很感兴趣，或者是想每天锻炼的朋友，可以考虑入手如果只是想玩玩，没必要，我是大傻呗 你别看东盛每次都是排队排的满满当当的第一次去我真的觉得还行第二次就感觉品种太少了，真的不太行肉的质量其实还蛮不错，茶也还行，也就这还行了那个烤生蚝的师傅，真的能磨洋工，两个小时就做了一次如果下一次没有人邀请我去，我自己是不会去的，好吧还不如楼下的牛牛说到这里，脸上长痘痘的朋友要小心楼下的老阿姨，他会让你去好像5楼，不知道要干啥，听说是给你整半个脸，然后另外半个要收费，总不能免费体验半个出去吧，那肯定很奇怪但是像我们这么聪明的孩子，肯定不会上老阿姨的当啦~ 这几张照片反正不是我拍的，去的是那个好像叫超级植物公司我同学大众点评上找的，本来以为能消磨几个小时时间，本来以为是个什么展览的地方结果!结果！！结果！！！就是一个小商店，卖跟植物有关的环保物品的还有就是这是在一个像小厂房一样的地方，都是摄影师带客人拍照的但是我觉得不行，我也不会带我以后的女朋友来这种地方直接X掉 不管说这种峰会是什么性质，是那种几个老板或者几个投资人举办的一种带合作性质还是怎么样的，对于我来说确实是见了见世面最主要还是少了节课，嘻嘻嘻滴水湖里面那个酒店的环境还是很不错的本来说是包午饭的，然后我们看到了下面这张图没想到听个峰会还能吃个自助，直接爽歪歪结果，就 还有什么呢我想想永劫无间我还是很轻松上了个陨星，还是很满足的学校的一等奖学金差一点还是很可惜，只能混个二等，这个学校没有奖学金才不正常对于未来一年还是看的挺清晰的，玩好最后几个月，好好享受大学生活好像我们两个寝室就我还没有女朋友了，这几个b也天天催我，就我们这个专业怎么去认识女生嘛，我又不是社牛，更何况在原来有很多痣的情况下又开始发痘痘了，我mm好像比我还捉急，又涂这涂那的，好像一时半会也好不了反正要是能上岸的话，我一定好好考虑一下 英雄联盟手游其实还不错的，就是年纪大了，手指已经不灵活了，还是敲键盘更加熟练就看看好友上上线，看一看那个…..，就可以了……我入手仙剑系列真的是因为仙剑3是我童年电视剧比较喜欢的了仙剑7玩下来真的，只能说便秘，它之前引以为傲的剧情已经消失了还好只是买的标准版，里面好像送的小礼品，如果有想要的我就直接送了（好像就两个徽章，一个书签）我没图，东西在学校里 下次写blog也不知道是什么时候了，反正想到就写呗，有缘再见","categories":[],"tags":[]},{"title":"枚举","slug":"9-1","date":"2021-08-31T16:00:00.000Z","updated":"2022-01-06T09:19:16.878Z","comments":true,"path":"2021/09/01/9-1/","link":"","permalink":"http://example.com/2021/09/01/9-1/","excerpt":"","text":"三元表达式表达式1？表达式2：表达式3；表达式1一般为一个关系表达式如果表达式1为true 整个3元表达式为表达式2如果表达式2为false 整个3元表达式为表达式3*表达式2的结果类型必须与表达式3的结果类型一致，并且也要跟整个三元表达式的结果类型一致 产生随机数1、创建能够产生随机数的对象没有对象 new一个例：random r=new random（）；r就是对象2、让产生随机数的对象调用方法来产生随机数r.Next()来产生随机数int rnumber=r.Next（1,10）//返回一个1-9的随机数，左闭右开区间 *常量声明常量的语法：const 变量类型 变量名=值；最大特点就是不能被重新赋值 枚举语法：[public] enum 枚举名{ 值1， 值2， 值3， ……}public:访问修饰符 公开的 哪都可以访问enum:关键字，声明枚举的关键字枚举名:要符合Pascal命名规范将枚举写到命名空间下，类的外面（整个工程都能用）枚举就是一个简单的变量类型** 只是声明、赋值、使用方式不同 本质还是存储数据的例：public enum Gender{ 男， 女}//声明枚举 genderGender gender=Gender.男；-&gt;变量类型 变量名=值这里的Gender就是自己建的变量类型*枚举和int和string之间的类型转换枚举类型默认可以和int类型进行转换 和int类型是兼容的例：int n=（int）state这里的state是枚举类型//首先所有类型都能转换成string类型 调用tostring（）；int n1=10；string s=n1.ToString（）；枚举也不例外 *将字符串换成枚举类型//比较麻烦的例子： string s=“0” 枚举类型 state=（枚举类型）Enum.Parse(typeof（枚举类型）,s) //调用parse方法是为了让他帮我们将一个字符串类型转换成枚举类型","categories":[],"tags":[]},{"title":"要开学啦，作业补不完了好紧张^^","slug":"8-24","date":"2021-08-29T16:00:00.000Z","updated":"2022-01-06T09:19:16.877Z","comments":true,"path":"2021/08/30/8-24/","link":"","permalink":"http://example.com/2021/08/30/8-24/","excerpt":"","text":"8-24for循环for（循环体1；循环体2；循环体3）{ 循环体；}表达式1位声明环境变量 记录循环次数表达式2为循环条件表达式3一般为改变循环条件的代码 8-29试着让自己静下来在这个快节奏的生活中不必让自己时刻忙碌起来不需要滴滴滴的消息不需要刷刷刷的游戏不需要为了..而..试着让自己放空让自己的灵魂畅游整个世界幻想着一切自己从前不敢想的事情回忆自己的过去回忆自己的错误回忆那仅剩的几丝美好或许有的错误不可补救但那又怎么样呢我从不质疑自己的决定长路漫漫在自己感兴趣的道路上不断爬行结识志同道合的三两好友在每天都在改变的代码中穿行为了自己的理想不断努力就够了（自己nt 整天想些有的没的 直接就学不了） tip：逆向for循环 forr两下tab水仙花数指的是百位的立方+十位的立方+个位的立方==这个数字console.write();跟\\n性质一样 换行 8-30怎么形容我现在的状态呢就是挺烦躁的感觉又很多事压在心里但其实又什么事都没有玩了几分钟游戏更烦躁了也不太想跟他们出去玩就整个人 挺压抑的很烦~（或许是自己今日下午看了会直播，以前一个战队的好兄弟，由于很多原因，能吵得很严重那种）或许自己 或许别人 对得起自己就行吧 *将数字转化成想要的数字类型可以用：convert.toint32(“3”);使用convert成功运行 失败抛出异常还可以用int.parse(“3”);与convert结果运行一模一样toint32本质上是调用了int.parse 所以本质上是一样的但是parse这个语句内部效率更高 不过可以忽略不计除了int.parse还有double decimal.parse**int.tryparse尝试将字符串转换成int类型例：int number =0;bool b=int.TryParse(“123”,out number);cw(b);cw(number);转换成功将“123”变成number 输出 并返回true失败的话 number返回 0 并返回false不会抛出异常性能相对于更高tryparse是一个方法（函数）","categories":[],"tags":[]},{"title":"八月第一天","slug":"8-1","date":"2021-07-31T16:00:00.000Z","updated":"2022-01-06T09:19:16.873Z","comments":true,"path":"2021/08/01/8-1/","link":"","permalink":"http://example.com/2021/08/01/8-1/","excerpt":"","text":"逻辑与 优先级 高于 逻辑或判断闰年什么的就不说了 挺简单的ctrl+k+d要记住啊 排版很重要！！最后一行代码后留三个大括号学个c# 车轱辘都碾到脸上了 .哧溜哧溜 等哪天闲的没事干 把这个博客的界面好好搞一下这个spfk的源代码我还没看过顺便可以整理一下当时搞这个博客的过程我记得我好像搞了一整天毕竟都是报错 古剑3刚开始这个剧情是真的不错景色也很好 希望我预购的仙剑7至少是这个高度好吧","categories":[],"tags":[]},{"title":"7-31","slug":"7-31","date":"2021-07-30T16:00:00.000Z","updated":"2022-01-06T09:19:16.870Z","comments":true,"path":"2021/07/31/7-31/","link":"","permalink":"http://example.com/2021/07/31/7-31/","excerpt":"","text":"不兼容的类型转换：比如string与int 或者string与double需要用到convert类型转换例子：string s =“123”； double d= convert.todouble(s); int n =convert.toint32(s); console.writeline(n); console.writeline(d); console.readkey();但是用convert进行转换的时候需要满足能转换如果是abc这种转换成double 就不成立 *console.readline（）接受用户的数据的时候一定是string类型会涉及到类型转换如果算数两边都是int型 但是答案是double型 左边用double接收 还是int除非右边有一个转换成double型 可以0.1 ++ – 自加自减 值相同加加减减在后 先取值后运算加加减减在前 先运算后取值 一元运算符（一个操作数完成）优先级高于二元运算符（两个或以上操作数+ -）） 关系运算符（略）&gt;&lt; &gt;= &lt;=……. bool类型 描述对错 true false &amp;&amp;（与） ||（或） ！（非） 没多少好说的 就到这里吧 有没有好看的番啊 都看的差不多了 ヽ（≧□≦）ノ","categories":[],"tags":[]},{"title":"7-26","slug":"7-26","date":"2021-07-25T16:00:00.000Z","updated":"2022-01-06T09:19:16.868Z","comments":true,"path":"2021/07/26/7-26/","link":"","permalink":"http://example.com/2021/07/26/7-26/","excerpt":"","text":"网线分为 568A 和568B568A主要应用于交叉线 什么意思呢 就是网线两头 一端为568A 另一端为568B线序的排布为 白绿 绿 白橙 蓝 白蓝 橙 白棕 棕568B则主要应用于直连线 意思就是网线两头都是为568B排布568B的线序排布为白橙 橙 白绿 蓝 白蓝 绿 白棕 棕 过去568A和568B是要分情况使用的 在交换机 HUB PC 路由器之间有着明确的划分的但是随着科技的发展 这种需要辨别的情况就日渐减弱在我们国家最常见的就是568B 这种线序排布已经满足我们日常生活的需要了 虽然分为8根线 但是真正起作用的还是只有四根 为白橙 橙 白绿 绿 对用B的 1 2 3 6这四根另外 4 5 号线对应的蓝 白蓝 起到的是电话线 7 8 白棕 棕 则是监控线 真正做这个网线其实很容易 没什么好说的为什么会聊到这个呢 主要是实习的时候要求帮个忙 但是我不会 老尴尬了虽然是学的软件 但是呢 我觉得这种技能还是比较基础的 就记录下来了另外还有些测试硬盘 重装系统 安装盗版windows 哈哈哈就更没什么好说的了~ c# （第几天 忘记了）还是很基础的一天： 连接两个字符串 （当+两边有一边为字符串就是起这个作用）占位符：这个东西在java好像没遇到过 c里面不记得了c#中占位符是特别重要的一个符号了{0}{1}{2}类似这种 输出的时候：Console.WriteLine(“要输出的是{0}{1}”,n1,n2);n1,n2之前定义过的 比之前用+没那么容易出错多填坑 不报错 没实际效果少填了坑 出现异常（但是语法并没有错误，不过在程序运行期间出现问题，使得程序不能正常运行）占位符最终是按照挖坑的顺序输出占位符在一个输出语句中始终要从{0}开始 不管之前写到哪里{0:0.00}表示小数点后保留两个小数 交换两个数字 不用第三方变量a=a+bb=a-ba=a-b 接收用户在控制台的输入Console.ReadLine();但是需要定义一个字符串类型的变量来存储输入的数据string例：string a = Console.ReadLine(); 转义符 ‘\\’加一个字符组成一个由特殊意义的字符：\\n 换行\"表示一个英文下的双引号\\t 表示一个tab键的空格 多用于排版\\b 表示一个退格键 放在字符串两边没有效果\\表示一个\\ @符号写在“”之前表示让\\不作为转义符 单纯作为一个\\第二个作用是保留原格式输出 在char中 只能写一个字符 但是在单引号之间写比如一个\\b 此处的\\表示转义的作用这个\\表示的是backspace 即退格键 算数运算符 /（整除） % (取余) 要求等号两边参与操作数的类型必须一致，如果不一致，满足下列条件，发生隐式转换类型兼容 且 目标类型大于源类型：比如int转换成 double如果要将double转换成int 需要强制类型转换（待转换的类型）要转换的值；比如说d=300.6 int n =（int）d；最后会输出300 头疼 gaming ^_^","categories":[],"tags":[]},{"title":"卧槽，管","slug":"卧槽，管","date":"2021-07-17T16:45:53.000Z","updated":"2022-01-06T09:19:16.881Z","comments":true,"path":"2021/07/18/卧槽，管/","link":"","permalink":"http://example.com/2021/07/18/%E5%8D%A7%E6%A7%BD%EF%BC%8C%E7%AE%A1/","excerpt":"","text":"谢谢你 泽元 你就是未来战士","categories":[],"tags":[]},{"title":"咕咕咕","slug":"7.18","date":"2021-07-16T16:00:00.000Z","updated":"2022-01-06T09:19:16.870Z","comments":true,"path":"2021/07/17/7.18/","link":"","permalink":"http://example.com/2021/07/17/7.18/","excerpt":"","text":"// 都是这样注释的 没的区别 注销和解释单行注释//多行注释 /* 内容*/文档注释 /// 用来解释类和方法 vs常用快捷键：ctrl+k+d 快速对齐 (好像真的没有什么用)ctrl+z 撤销ctrl+s 保存ctrl+j 快速弹出智能提示 没用！！shift+homeshift+end 快速选中行、行尾切换ctrl+k+c注释所选代码ctrl+k+u取消所选代码的注释 #region#endregion 此两行用于折叠冗余代码 数据类型 没有什么好说的char(只能存一个’x’) string字符串”xxx”decimal类型 后缀要加m 不加m转换为double类型称其为金钱类型 命名规范：第一个单词首字母小写后面单词首字母都要大写 多用于变量 每个单词首字母都要大写 多用于类名 ¿ ¿ ¿虽然没学到什么 但是看得我好累啊 休息 休息去 好久不玩 pubg 以前买了不玩是因为我是在是太菜了这几天天天训练场练枪 发现这个枪是真的难压 也太飘了要不是有人陪我一起玩 真的没几天真的是又有点劝退我了我还是适合那种种种地 看看剧情的养身游戏啊~","categories":[],"tags":[]},{"title":"辛丑六月初六","slug":"七月十五","date":"2021-07-14T16:00:00.000Z","updated":"2022-01-06T09:19:16.880Z","comments":true,"path":"2021/07/15/七月十五/","link":"","permalink":"http://example.com/2021/07/15/%E4%B8%83%E6%9C%88%E5%8D%81%E4%BA%94/","excerpt":"","text":"为了unity学c#好吧听了一会确实跟java差不多 可以边划边听 很nice 大概好像是：using 来调用包namespace 项目名{ class 类名{ main主方法{} }} 他讲的好多都是.Net的 用的都是visual studio 就是听一听我就是只学c# Console.WriteLine(“hello world”);Console.Readkey(); // 暂停当前程序等待用户按下任意键继续 并且这个按下的键会显示在我们的控制台中 卧槽这个VS 生成 解决方案能直接告诉你哪里错了 要输入什么 这不比c java 找错误来的方便 第一天的课确实无聊 终于可以玩游戏啦有人安利我玩这个勇敢的心：世界大战 说是能让人玩哭 那我是不信的","categories":[],"tags":[]},{"title":"暑假","slug":"暑假","date":"2021-07-13T16:00:00.000Z","updated":"2022-01-06T09:19:16.883Z","comments":true,"path":"2021/07/14/暑假/","link":"","permalink":"http://example.com/2021/07/14/%E6%9A%91%E5%81%87/","excerpt":"","text":"暑假真的天天跟好友玩游戏确实是很快乐的一件事但是每次一放假就又想着学 啊哈哈 我确实有什么大病unity制作是基于c#听说c#跟java是好兄弟我给我自己大概2-3周把c#入门先学会 也有可能会更长毕竟别人叫我打游戏我也不太会拒绝争取在开学前能初步了解和使用unity（今天踢球受伤了 难受）好希望暑假是充实且有意思的（约我出去玩 我也想天天噶在外面 叫我我是不会拒绝的¿）","categories":[],"tags":[]}],"categories":[],"tags":[]}